---
title: A data wrangling case with spreadsheets using R
author: Cristóbal Alcázar
date: '2018-01-16'
slug: a-data-wrangling-case-with-r
categories: [R]
tags: [R, Data-Science]
comments: yes
showcomments: yes
showpagemeta: yes
---



<div class="figure">
<img src="img/spreadsheet_shock.jpg#center" style="width:60.0%" />

</div>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Data wrangling is the process of mapping raw data to a format more suitable to model, visualize or in general to work it. This process is usually thought as an early stage of the data analysis pipeline (<em>e.g. I need a nice table to start the analysis</em>). But the skills involved in the process are useful whenever you need to reshape or look your data from different perspectives, or when you need to adapt some new tool that required a specific format. The reflexion:</p>
<blockquote>
<p><em>data wrangling skills have more to say that only in an initial stage of the analysis, the latter can be augmented with these skills, enabling more flexibility and expressiveness in the whole pipeline.</em></p>
</blockquote>
<p>But the reason of this post is show you the essential of data wrangling: dominate data or take control of it. As you know, data in real life aren’t always friendly and is not uncommon to found problems relative to the shape or format. An one case that contain both of these problem are the spreadsheet data.</p>
<p>(Just) to be fair not all the spreadsheets are a problem. Let me clarify what I refer by “problem”, <em>the mess of more than one table per sheet like islands floating in a ocean of blank cells with clouds of metainformation headers relative to the tables…ok.</em></p>
<p>You can look by yourself what I try to say in the following magistral example, but first some context. Below of this paragraph you can find a series of tweets belonged to very well known data scientists (<em>if you don’t hear about them, I strongly recommend that you follow them</em>). The discussion is about a challenge to turn <a href="https://t.co/v9ucC0Vj2t" target="_blank">this spreadsheet</a> (a xlsx file) into a tidy data–<em>the grace is that the spreadsheet suffer the problems that I tried to describe</em>–and <a href="http://varianceexplained.org/" target="_blank">David Robinson (<em>the challenged</em>) </a>deal with the problem in <a href="http://rpubs.com/dgrtwo/tidying-enron" target="_blank">a very simple and fluently way</a>.</p>
{{% tweet "717815339480977410#center" %}}
{{% tweet "718170667573579776" %}}
<p>In the rest of the post I will dedicate to highlight some steps of the David Robinson answer to the tweet challenge, and then apply the insights on a case of data contained in multiple “xlsx”&quot; files with many sheets.</p>
</div>
<div id="the-highlights-steps" class="section level2">
<h2>The highlights steps</h2>
<div id="step-1-the-coordinate-view" class="section level3">
<h3>Step 1: The coordinate-view</h3>
<p>Consider the next innocent table as an example.</p>
<div class="figure">
<img src="img/murdervictims.png#center" style="width:65.0%" />

</div>
<p>It’s easy to import the above spreadsheet with the <code>readxl::read_excel</code> function and obtain a rectangular table in R, filled with missing values (NA) instead of blank cells. You can take a look of the first six rows.</p>
<pre class="r"><code>library(readxl)
df &lt;- readxl::read_excel(&quot;./innocent_table.xlsx&quot;)
df</code></pre>
<pre><code>## # A tibble: 6 x 6
##                               X1    X2    X3    X4    X5    X6
##                            &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 Expanded Homicide Data Table 8    NA    NA    NA    NA    NA
## 2                 Murder Victims    NA    NA    NA    NA    NA
## 3           by Weapon, 2004-2008    NA    NA    NA    NA    NA
## 4                        Weapons  2004  2005  2006  2007  2008
## 5                          Total 14210 14965 15087 14916 14180
## 6                Total firearms:  9385 10158 10225 10129  9484</code></pre>
<p>The importance of this step is to describe explicitly the position of each cell-value of the spreadsheet into the R’s data frame structure–<em>in row</em> <span class="math inline">\(i\)</span> <em>and column</em> <span class="math inline">\(j\)</span> <em>you found the value</em> <span class="math inline">\(x_{i,j}\)</span>–and the following function, created and used by David Robinson in his answer, reorganize the data accordingly.</p>
<pre class="r"><code>library(dplyr)
library(tidyr)
tidy_excel &lt;- function(x) {
  # x is a data imported from an excel file with readxl::read_excel
  #   function.
  # Return a data frame with the coordinate view representation.
  x %&gt;% 
    setNames(seq_len(ncol(x))) %&gt;% 
    mutate(row = row_number()) %&gt;% 
    tidyr::gather(column, value, -row) %&gt;% 
    mutate(column = as.integer(column)) %&gt;% 
    group_by(row) %&gt;% 
    filter(!all(is.na(value))) %&gt;% 
    group_by(column) %&gt;% 
    filter(!all(is.na(value))) %&gt;% 
    ungroup() %&gt;% 
    arrange(column, row)
}

tidy_excel(df)
## # A tibble: 138 x 3
##      row column                          value
##    &lt;int&gt;  &lt;int&gt;                          &lt;chr&gt;
##  1     1      1 Expanded Homicide Data Table 8
##  2     2      1                 Murder Victims
##  3     3      1           by Weapon, 2004-2008
##  4     4      1                        Weapons
##  5     5      1                          Total
##  6     6      1                Total firearms:
##  7     7      1                       Handguns
##  8     8      1                         Rifles
##  9     9      1                       Shotguns
## 10    10      1                     Other guns
## # ... with 128 more rows</code></pre>
<p>As you can observe, the cells of the spreadsheet are melted into one column (<em>value</em>) and two new index-variables are created, one by each dimension (<em>row</em> and <em>column</em>), to mapping a cell coordinate of the spreadsheet with his content. This is the reason of the section title part <em>“coordinate-view”</em>.</p>
<p>The legitimate question now is <strong>why can be useful the coordinate-view? What is the advantage with the previous form?</strong></p>
<blockquote>
<p><strong>A:</strong> <em>It’s possible to take advantage of manipulate data based on the physical position of the template using operations over columns and rows. In fact,</em> <code>tidy_excel</code> <em>apart of reshape data into the coordinate-view is also an example of this. Pay attention to the following code snippet from the function definition of</em> <code>tidy_excel</code>.</p>
</blockquote>
<pre class="r"><code># ...from the definition of tidy_excel
  group_by(row) %&gt;%  # group by row index
  filter(!all(is.na(value))) %&gt;%  # discard empty rows (row-groups that contain only NA values)
  group_by(column) %&gt;%  # group by col index
  filter(!all(is.na(value))) # discard empty cols (col-groups that contain only NA values)</code></pre>
<p>We can give more life to the above answer with an example. Imagine that we want to know the index of a header that contain “weapon” and years (2004…2008) of the previous table. Indeed like the data is very small you can know the answer just by looking. But suppose that we have multiple spreadsheets like that and the row index header can vary between the files. In this case it would be useful a way to identify the row-index that contain the header and deal with the particularities of each spreadsheet.</p>
<pre class="r"><code># 4-row
df
## # A tibble: 23 x 6
##                                X1    X2    X3    X4    X5    X6
##                             &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Expanded Homicide Data Table 8    NA    NA    NA    NA    NA
##  2                 Murder Victims    NA    NA    NA    NA    NA
##  3           by Weapon, 2004-2008    NA    NA    NA    NA    NA
##  4                        Weapons  2004  2005  2006  2007  2008
##  5                          Total 14210 14965 15087 14916 14180
##  6                Total firearms:  9385 10158 10225 10129  9484
##  7                       Handguns  7286  7565  7836  7398  6755
##  8                         Rifles   403   445   438   453   375
##  9                       Shotguns   507   522   490   457   444
## 10                     Other guns   117   138   107   116    79
## # ... with 13 more rows

# identify the header table in the coordinate-view representation
header_names_pattern &lt;- &quot;Weapons|2004|2005|2006|2007|2008&quot;

# filter the column value based on a string pattern
df %&gt;% 
  tidy_excel %&gt;%  # apply the coordinate-view
  filter(stringr::str_detect(value, header_names_pattern))
## # A tibble: 7 x 3
##     row column                value
##   &lt;int&gt;  &lt;int&gt;                &lt;chr&gt;
## 1     3      1 by Weapon, 2004-2008
## 2     4      1              Weapons
## 3     4      2                 2004
## 4     4      3                 2005
## 5     4      4                 2006
## 6     4      5                 2007
## 7     4      6                 2008</code></pre>
<p>The above code is just a logical filter operation over the data. In other words, we give to the <code>dplyr::filter</code> function a logical vector (<em>TRUE / FALSE</em>) of the same length that the rows of the data and return only the rows in which the index is <em>TRUE</em>. The coordinate view allow us to know directly in which row and column the relevant values are located in the spreadsheet. If we pay atention to the row variable you can see that the header content is located in the fourth row.</p>
<p>How we generate the logical vector with <code>stringr::str_detect</code> is the following step.</p>
</div>
<div id="step-2-make-your-shot-with-regex" class="section level3">
<h3>Step 2: Make your shot with regex</h3>
<blockquote>
<p><em>“A regular expression (or just regex) is a sequence of character that define a search pattern.”</em> (<a href="https://en.m.wikipedia.org/wiki/Regular_expression" target="_blank">Wikipedia</a>)</p>
</blockquote>
</div>
</div>
<div id="the-case" class="section level2">
<h2>The Case</h2>
<p><strong>Describe better the problem and the goal</strong></p>
<p>The aim of this case is use the insights of the highlights step and extract tables from three excel files (<em>xlsx</em>), Each of these correspond to a year files contain multiple sheets with the same information but different months.</p>
<ul>
<li>Use the name of the files and sheet as metadata information to then identify each data</li>
<li>Each excel sheet into one data frame</li>
</ul>
<pre class="r"><code># first we load the packages used during the analysis
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(readxl)


files &lt;- list.files(&quot;./post_data/a_data_wrangling_case_with_spreadsheets_using_r&quot;, full.names = TRUE)
files
## [1] &quot;./post_data/a_data_wrangling_case_with_spreadsheets_using_r/deb_2013.xlsx&quot;
## [2] &quot;./post_data/a_data_wrangling_case_with_spreadsheets_using_r/deb_2014.xlsx&quot;
## [3] &quot;./post_data/a_data_wrangling_case_with_spreadsheets_using_r/deb_2015.xlsx&quot;

sheet_per_file &lt;- map(files, readxl::excel_sheets)
sheet_per_file
## [[1]]
##  [1] &quot;Enero&quot;      &quot;Febrero&quot;    &quot;Marzo&quot;      &quot;Abril&quot;      &quot;Mayo&quot;      
##  [6] &quot;Junio&quot;      &quot;Julio&quot;      &quot;Agosto&quot;     &quot;Septiembre&quot; &quot;Octubre&quot;   
## [11] &quot;Noviembre&quot;  &quot;Diciembre&quot;  &quot;Hoja13&quot;    
## 
## [[2]]
##  [1] &quot;Enero&quot;      &quot;Febrero&quot;    &quot;Marzo&quot;      &quot;Abril&quot;      &quot;Mayo&quot;      
##  [6] &quot;Junio&quot;      &quot;Julio&quot;      &quot;Agosto&quot;     &quot;Septiembre&quot; &quot;Octubre&quot;   
## [11] &quot;Noviembre&quot;  &quot;Diciembre&quot; 
## 
## [[3]]
##  [1] &quot;Enero 2015&quot;      &quot;Febrero 2015&quot;    &quot;Marzo 2015&quot;     
##  [4] &quot;Abril 2015&quot;      &quot;Mayo 2015&quot;       &quot;Junio 2015&quot;     
##  [7] &quot;Julio 2015&quot;      &quot;Agosto 2015&quot;     &quot;Septiembre 2015&quot;
## [10] &quot;Octubre 2015&quot;    &quot;Noviembre 2015&quot;  &quot;Diciembre 2015&quot;</code></pre>
<p>We need a pair of arguments for <code>read_excel</code> to read each sheet:</p>
<ul>
<li><p><em>path to the xlsx file</em></p></li>
<li><p><em>the name of the sheet</em>.</p></li>
</ul>
<p>A possible way to build these pair of arguments are the <strong>cross product</strong> between the variables <code>files</code> and <code>sheet_per_file</code>. But before that the crude world gives us an inconvenient, the first file contain more than twelve sheet and, as we know, a year has twelve months..so a sheet is being a fly (<em>Hoja13</em>).</p>
<pre class="r"><code># for each sheet name vector we discard the names that aren&#39;t relevant
pattern &lt;- c(&quot;Enero|Febrero|Marzo|Abril|Mayo|Junio|Julio|Agosto|Septiembre|Octubre|Noviembre|Diciembre&quot;)
relevant_sheet_name &lt;- map(sheet_per_file, 
                           ~ .x[str_detect(.x, pattern)])</code></pre>
<p>We continue with the cross product (<code>purrr::cross</code>)…and we obtain a nested list of 36 element (<code>arg_list</code>), in which each element is a list of length two with the necessaries arguments to read each sheet. Below you can see the first two pairs of argument to feed <code>read_excel</code>.</p>
<pre class="r"><code>arg_list &lt;- map2(files, relevant_sheet_name, ~ list(.x, .y))
arg_list &lt;- map(arg_list, purrr::cross)
arg_list &lt;- purrr::flatten(arg_list)
head(arg_list, n = 2)
## [[1]]
## [[1]][[1]]
## [1] &quot;./post_data/a_data_wrangling_case_with_spreadsheets_using_r/deb_2013.xlsx&quot;
## 
## [[1]][[2]]
## [1] &quot;Enero&quot;
## 
## 
## [[2]]
## [[2]][[1]]
## [1] &quot;./post_data/a_data_wrangling_case_with_spreadsheets_using_r/deb_2013.xlsx&quot;
## 
## [[2]][[2]]
## [1] &quot;Febrero&quot;</code></pre>
<p>Now two things will happen, first I will iterate a list (<code>arg_list</code>) over a function, guess which one?…<code>read_excel</code> to read each sheet and store in a list called <code>raw_data</code>. Then I will give a name to each element (<em>dataframe</em>) of the output list <code>raw_data</code>. We need the metainformation to identify each dataframe with his corresponding file and sheet. So using <em>regex</em> we extract from each <code>arg_list</code> element the <u>year</u> and <u>month</u> from the first and second argument respectively. Look how the sheets are in <code>raw_data</code>, you can see the name after the dollar sign.</p>
<pre class="r"><code>raw_data &lt;- invoke_map(read_excel, arg_list)

# add metainformation from the names of the files and sheet into the name
# of elemenet list
list_names &lt;- map(arg_list, ~ paste(str_extract(.x[[1]], &quot;[0-9]+&quot;), 
                                    str_extract(.x[[2]], &quot;[aA-zZ]+&quot;), sep = &quot;_&quot;))

names(raw_data) &lt;- list_names
head(raw_data, n = 2)
## $`2013_Enero`
## # A tibble: 1,127 x 25
##    `DETALLE DEUDA VIGENTE`  X__1                     X__2
##                      &lt;chr&gt; &lt;chr&gt;                    &lt;chr&gt;
##  1      BONOS CORPORATIVOS  &lt;NA&gt;                     &lt;NA&gt;
##  2  al 31 de enero de 2013  &lt;NA&gt;                     &lt;NA&gt;
##  3                    &lt;NA&gt;  &lt;NA&gt;                     &lt;NA&gt;
##  4                    &lt;NA&gt;  &lt;NA&gt; *VALOR U.F.(31/01/2013)=
##  5                     Rut  &lt;NA&gt;                 Sociedad
##  6                76675290     K           AD Retail S.A.
##  7                76675290     K           AD Retail S.A.
##  8                94272000     9           AES Gener S.A.
##  9                94272000     9           AES Gener S.A.
## 10                94272000     9           AES Gener S.A.
## # ... with 1,117 more rows, and 22 more variables: X__3 &lt;chr&gt;, X__4 &lt;chr&gt;,
## #   X__5 &lt;chr&gt;, X__6 &lt;chr&gt;, X__7 &lt;chr&gt;, X__8 &lt;chr&gt;, X__9 &lt;chr&gt;,
## #   X__10 &lt;chr&gt;, X__11 &lt;chr&gt;, X__12 &lt;chr&gt;, X__13 &lt;chr&gt;, X__14 &lt;chr&gt;,
## #   X__15 &lt;chr&gt;, X__16 &lt;chr&gt;, X__17 &lt;chr&gt;, X__18 &lt;chr&gt;, X__19 &lt;chr&gt;,
## #   X__20 &lt;chr&gt;, X__21 &lt;chr&gt;, X__22 &lt;chr&gt;, X__23 &lt;chr&gt;, X__24 &lt;chr&gt;
## 
## $`2013_Febrero`
## # A tibble: 1,131 x 25
##        X__1 `DETALLE DEUDA VIGENTE`                     X__2
##       &lt;chr&gt;                   &lt;chr&gt;                    &lt;chr&gt;
##  1     &lt;NA&gt;      BONOS CORPORATIVOS                     &lt;NA&gt;
##  2     &lt;NA&gt;                      al                    41333
##  3     &lt;NA&gt;                    &lt;NA&gt;                     &lt;NA&gt;
##  4     &lt;NA&gt;                    &lt;NA&gt; *VALOR U.F.(28/02/2013)=
##  5      Rut                    &lt;NA&gt;                 Sociedad
##  6     &lt;NA&gt;                    &lt;NA&gt;                     &lt;NA&gt;
##  7 76675290                       K           AD Retail S.A.
##  8 76675290                       K           AD Retail S.A.
##  9 94272000                       9           AES Gener S.A.
## 10 94272000                       9           AES Gener S.A.
## # ... with 1,121 more rows, and 22 more variables: X__3 &lt;chr&gt;, X__4 &lt;chr&gt;,
## #   X__5 &lt;chr&gt;, X__6 &lt;chr&gt;, X__7 &lt;chr&gt;, X__8 &lt;chr&gt;, X__9 &lt;chr&gt;,
## #   X__10 &lt;chr&gt;, X__11 &lt;chr&gt;, X__12 &lt;chr&gt;, X__13 &lt;chr&gt;, X__14 &lt;chr&gt;,
## #   X__15 &lt;chr&gt;, X__16 &lt;chr&gt;, X__17 &lt;chr&gt;, X__18 &lt;chr&gt;, X__19 &lt;chr&gt;,
## #   X__20 &lt;chr&gt;, X__21 &lt;chr&gt;, X__22 &lt;chr&gt;, X__23 &lt;chr&gt;, X__24 &lt;chr&gt;</code></pre>
</div>
